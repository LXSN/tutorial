[第二节]走进函数模板
你需要一个模具！
――当你在浇铸时
上一节，我们粗略的了解了模板的概念
以及函数模板的基本定义方法
今天，我们来深♂入函数模板
探究它的功能与作用
[/]模板参数命名方法
面对模板参数，或者说得准确一点，是模板形参
在此之前，我一直使用的是T，那么在实际使用过程中，应该注意什么呢？
1.首字母一定要大写
如：In/Out
2.可以用一个字母或一个字母跟数字或者是T字母按字母顺序顺延下去
比如T/T1/T2或T/U/V
[/]在实例化之后
在上一节我们讲到，函数模板实例化之后，成为了模板函数，实际上模板函数与普通的函数没有太大的区别，完全可以理解为把模板参数带入到代码中的函数，举个例子
//max<>()定义已经在上一节给出
int (*fp)(int,int) = max<int>;
可以看到，我们将max用<int>实例化之后，就和之前那个int_max()几乎毫无区别
然后我们也可以这样调用函数：
 (*fp)(12,25);
 fp(12,25);//省略“*”
就等同于
max<int>(12,25);
同样的道理,也可以像这样：
void apply(double (*)(double,double));
apply(max<double>);
不难发现T被换成了double之后，就完全匹配上面的参数类型了
函数模板如果不实例化为模板函数那么就不存在这个函数，对应的，就没有这个函数的地址
[/]非类型的模板参数
除了类型之外，模板参数还可以有：
std::nullptr_t
整数类型
左值引用类型
指针类型
成员指针类型
枚举类型
这些的值必须是编译时就已经确定的值，比如5, (3 + 2), nullptr, numeric_limits<int>::max() 
小结：
1.正确命名模板参数
2.实例化之后的模板函数其实与其他函数区别不大
3.模板必须实例化才存在
4.非类型的模板参数

